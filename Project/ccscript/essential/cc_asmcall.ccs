import "../essential/asm65816.ccs"
import "../essential/jsl_rts.ccs"

define cc_argv   = 0x97BA // Control code argument vector
define cc_argc   = 0x97CA // Control code argument count

command adr24(ptr) "[{byte[0] ptr} {byte[1] ptr} {byte[2] ptr}]"

command cc_asmcall(routine, ret_type) "[1F 60 {adr24(routine)} {byte ret_type}]"

/*
 * Replaces the unused control code [1F 60 XX] with:
 *   cc_asmcall(adr24 routine, byte ret_type)
 *
 * Where:
 *  'routine' is the pointer to the JSL routine to run
 *  'ret_type' is tells the return type and in which register to store it:
 *     'ret_type' bits: "l00000rr"
 *       l = "long" return type flag (function returns a 32-bit number rather than a 16-bit number)
 *       r = which register to store the return value into:
 *         0: NONE
 *         1: RESULT
 *         2: ARGUMENT
 *         3: COUNTER
 *
 * 'ret_type' cheatsheet in case the bitfield explanation was confusing:
 *   0x00 = NONE
 *   0x01 = RESULT register, 16-bit number
 *   0x02 = ARGUMENT register, 16-bit number
 *   0x03 = COUNTER register, 16-bit number
 *   0x80 = NONE
 *   0x81 = RESULT register, 32-bit number
 *   0x82 = ARGUMENT register, 32-bit number
 *   0x83 = COUNTER register, 16-bit number (truncated because the COUNTER register is a 16-bit register)
*/

// 'ret_type' definitions for 'cc_asmcall'
define RET_NONE        = 0x00
define RET_RESULT      = 0x01
define RET_ARG         = 0x02
define RET_COUNTER     = 0x03
define RET_RESULT_LONG = 0x81
define RET_ARG_LONG    = 0x82

define SetTBoxCounter = 0xC10443
define SetTBoxResult  = 0xC1045D
define SetTBoxArg     = 0xC10489


define ENTRY_POINT = 0xC15494 // Entry point of control code [1F 60]
ROM[ENTRY_POINT] = {
            JSL   (CC_AsmCall)
            RTS   // Must end in RTS

            // Fill remaining unused bytes with NOP (5 bytes)
            NOP NOP NOP NOP NOP
}

CC_AsmCall: {
            REP   (0x30)
            LDY_a (cc_argc)
            CPY_i (3)
            BCS_a (DoCall) // Branch if fetched 3 bytes plus current byte
              SEP   (0x20)
              TXA                 // Current byte
              STA_y (cc_argv)
              REP   (0x20)
              INC_a (cc_argc)     // Increment argument count
              LDA_i (ENTRY_POINT) // Return pointer to self (to fetch the next byte)
              RTL

DoCall:     // Allocate local variables
            REP   (0x31)
            PHD
            TDC
            ADC_i (-0x12)    // 0x12 bytes
            TCD

            SEP   (0x10)
            STX_d (0x00)     // Store 'ret_type'

            LDA_a (0x97BC)   // cc_argv+2 (I could only wish CCScript accepted compile-time math expressions...)
            STA_a (0x0A5C)
            LDA_a (cc_argv)
            STA_a (0x0A5A)
            REP   (0x30)     // Call with 16-bit accumulator/indexes
            JSL   (0xC09D9E) // Long ASM call from $0A5A

            REP   (0x30)
            STA_d (0x0E)     // Store return value into 0x0E (argument to SetTBoxResult/SetTBoxArg routines)
            STZ_d (0x10)     // Clear high byte

            SEP   (0x20)
            LDA_d (0x00)     // Load 'ret_type'
            BPL_a (NotLong)  // Check the 'l' bit
              LDX_d (0x06) // Low word of 32-bit return value
              STX_d (0x0E)
              LDX_d (0x08) // High word of 32-bit return value
              STX_d (0x10)
NotLong:    LDA_d (0x00)     // Load 'ret_type'
            AND_8 (0x03)     // mask only 'r' bits
            BEQ_a (Exit)     // If register == 0, don't store the return value anywhere
            DEC
            BEQ_a (ToResult) // If register == 1, store to RESULT register
            DEC
            BEQ_a (ToArg)    // If register == 2, store to ARGUMENT register

            // If we reached here, then register == 3 (store to COUNTER) register
ToCounter:  LDA_d (0x0E)   // Load low word of return value into accumulator
            JSL_RTS_C1(SetTBoxCounter) // Set COUNTER register to this value
            BRA_a (Exit)

ToArg:      JSL_RTS_C1(SetTBoxArg)
            BRA_a (Exit)

ToResult:   JSL_RTS_C1(SetTBoxResult)

Exit:       REP   (0x30)
            LDA_i (0)        // Return NULL (end CC processing)
            PLD
            RTL
}
